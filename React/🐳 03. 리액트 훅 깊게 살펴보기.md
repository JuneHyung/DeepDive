# 🐳 03. 리액트 훅 깊게 살펴보기

## 🌏  3.1 리액트의 모든 훅 파헤치기

### 👉 3.1.1 useState

함수형 컴포넌트 내부에서 상태를 정의하고, 관리해주는 훅.

```jsx
function Component(){
	let state = 'hello';
  function handleButtonClick(){
    state = 'hi'
  }
  
  return (
  	<>
    	<h1>{state}</h1>
    	<button onClick={handleButtonClick}>hi</button>
    </>
  )
}
```

변수에 상태 값을 저장한다고 했을 때, 위 코드는 동작하지 않는다.<br/>리액트에서 렌더링은 함수형 컴포넌트의 return을 실행한 다음 이 실행 결과를 이전 리액트 트리와 비교하여 리렌더링이 필요한 부분만 업데이트 한다.

```jsx
function Component(){
  const [,trigger] = useState()
  let state = 'hello';
  
  function handleButtonClick(){
    state = 'hi';
    riggerRender();
  }
  
  return (
  	... 동일 ...
  )
}
```

useState의 반환의 두 번쨰 원소를 실행해 리액트에서 렌더리잉 일어나게끔 했지만, 여전히 렌더링되지 않는다.

> **왜 그럴까?**
>
> 리액트의 렌더링은 함수혀 컴포넌트에서 반환한 결과물인 return 값을 비교해 실행되기 때문이다.
>
> 즉, **매번 렌더링이 발생할 때마다 함수는 다시 새롭게 실행**되고, 새롭게 실행되는 함수에서 **state는 매번 hello로 초기화**되기 때문이다.



#### 🔸 useState의 구조를 생각해보자.

```jsx
function useState(initialValue){
  let internalState = initialValue;
  function setState(newValue){
    initialValue = newValue;
  }
  return [initialValue, setState]
}

// --------------------------------------------
const [value, setValue] = useState(0)
setValue(0)
console.log(value) // 0
```

이미 구조분해할당으로 state의 값. 즉, value를 **이미 할당해 놓은 상태**이기 때문에 훅 내부의 setState를 호출해도 변경된 새로운 값을 반환하지는 못한다.<br/>=> state를 함수로 바꿔서 state의 값을 호출할 때마다 현재 state를 반환하게 하면 해결은 할 수 있지만, 사용하던 useState는 함수형태가아닌 상수처럼 사용하고 있다.

<br/>

❗ 이를 위해 **리액트는 클로저를 이용**했다

클로저를 통하여 useState내부에 선언된 setState가 종료되어도, 지역 변수인 state를 계속 참조할 수 있다.

> 실제 리액트 내부의 hook
>
> 이에 대한 정보는 리액트 깃허브 저장소를 참고해야하는데, 훅에 대한 구현체를 타고 올라가다 보면 `__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED`라는 문구를 마주한다.
>
> 일반 사용자의 접근을 차단하고, 실제 프로덕션 코드에서 사용하지 못하게 하기 위함으로 보이며, 접근하는것을 권장하지도 않는다.

해당 도서의 흉내낸 코드

❗ 실제 리액트 코드와는 차이가 있으며, 클로저로 구현되있다는 것을 참고용으로만 확인.

```javascript
const MyReact = function () {
	const global = {}
  let idx = 0;
  
  function useState(initialState){
    if(!global.states){
      // 애플리케이션 전체의 states배열을 초기화. 최초 접근이라면 빈 배열
      global.states = [];
    }
    
    // states 정보를 조회하여 현재 상태값이 있는지 확인하고, 없으면 초기값 설정.
    const currentState = global.states[index] || initialState
    // 조회한 현재값으로 업데이트
    global.states[index] = currentState;
    
    // 즉시 실행 함수로 setter 만듬.
    const setState = (function(){
      // 현재 index를 클로저로 가둬서 이후에도 계속 동일한 index에 접근하도록 만듬.
      let currentIndex = index;
      return function(value){
        global.states[currentIndex] = value;
        // 컴포넌트를 렌더링한다. 실제 렌더링 코드는 생략
      }
    })()
    
    // useState를 쓸 때 마다 index를 하나식 추가. index는 setState에 사용.
    // 하나의 state마다 index가 할당되어 그 index가 배열 값(global.states)를 가리키고 필요 마다 그 값을 가져온다.
    index = index+1;
    return [currentState, setState]
  }
}
```



#### 🔸 게으른 초기화 (lazy initialization)

`게으른 초기화`란 **useState에 변수 대신 함수를 넘기는 것**을 말한다.

공식문서에서는 useState의 초기값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용하라고 되어있다.

❗ 게으른 초기화 함수는 오로지 state가 처음 만들어질 때만 사용되고, 리렌더링 시 함수 실행은 무시된다.

> **왜 그럴까?**
>
> 리액트에서 렌더링이 실행될 때마다 함수형 컴포넌트의 ㅎ마수가 다시 실행되는데, useState의 값도 재실행된다.<br/>이 useState는 클로저가 존재하고, 클로저를 통해 값을 가져오며 초기값은 최초에만 사용되기 때문이다.

```jsx
const [count, setCount] = useState(Number.parseInt(window.localStorage.getItem(cachekey)));
```

useState에 위 같은 값 자체를 사용한다면 초기값이 필요한 최초렌더링과, 리렌더링 시에도 계속 해당 값에 접근해서 낭비가 발생한다. => 그렇기 때문에 함수 형태로 인수에 넘겨주는 편이 훨씬 경제적이다.

<br/>

### 📘 참고

* [React 공식문서 - lazy InitialStaet](https://reactjs.org/docs/hooks-reference.html#lazy-initial-state)

<br/>

<br/>

### 👉 3.1.2 useEffect

#### 🔸 useEffect란?

```jsx
function Component(){
  ...
  useEffect(()=>{
    ...
  }, [props, state])
}
```

첫 번쨰 인수로 실행할 부수 효과가 포함된 함수, 두번째 인수로 의존성 배열을 전달하는 형태이다.

의존성 배열이 변경될 때마다 useEffect에 작성된 콜백을 실행한다.

<br/>

> 어떻게?
>
> 함수형 컴포넌트는 렌더링 시마다 고유의 state와 props값을 가지고 있다.
>
> `useEffect`는 자바스크립트의 proxy나 데이터 바인딩, 옵저버같은 특별한 기능을 통해 값의 변화를 관찰하는 것이 아니고, **렌더링 할 때마다 의존성에 있는 값을 보면서 이 의존성의 값이 이전과 다른게 하나라도 있으면 부수 효과를 실행하는 평범한 함수**이다.

<br/>

#### 🔸 클린업 함수의 목적

일반적으로 이벤트를 등록하고 지울 때 사용해야 한다고 알려져 있다.

```jsx
import {useState, useEffect} from 'react';
export default function App(){
  const [counter, setCounter] = useState(0);
	function handleClick(){ setCounter(prev)=> prev+1 }
  
  useEffect(()=>{
    function addMouseEvent(){ console.log(counter); }
    window.addEventListener('click', addMouseEvent);
    
    // 클린업 함수
    return () => {
      console.log('클린업 함수 실행!', counter);
      window.removeEventListener('click', addMouseEvent)
    }
  },[counter])
  return (
  	<>
    	<h1>{counter}</h1>
    	<button onClick={handleClick}>+</button>
    </>
  )
}
```

**결과**

```text
클린업 함수 실행! 0
1
클린업 함수 실행! 1
2
...
```

❗ `클린업 함수`는 이전 counter값, 즉 **이전 state를 참조해 실행한다는 것**을 알 수 있다. 새로운 값과 함께 렌더링된 뒤에 실행되기 때문이다.<br/>여기서 중요한 것은 새로운 값을 기반으로 렌더링 뒤에 실행되지만 이 **변경된 값을 읽는 것이 아니라 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행된다**는 것.

<br/>

**최초 실행**

```javascript
useEffect(()=>{
  function addMouseEvent(){ console.log(1); }
  window.addEventListener('click', addMouseEvent);

  // 클린업 함수
	return () => {
		console.log('클린업 함수 실행!', 1);
		window.removeEventListener('click', addMouseEvent)
	}
}, [counter])
```

**이후 실행**

```javascript
useEffect(()=>{
  function addMouseEvent(){ console.log(2); }
  window.addEventListener('click', addMouseEvent);

  // 클린업 함수
	return () => {
		console.log('클린업 함수 실행!', 2);
		window.removeEventListener('click', addMouseEvent)
	}
}, [counter])
```

<br/>함수형 컴포넌트의 useEffec는 그 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면, 그 클린업 함수를 실행한 뒤에 콜백을 실행한다. 그렇기 때문에 이벤트를 추가하기 전에 이전에 등록했던 이벤트 핸들러를 삭제하는 코드를 클린업 함수에 추가하여 무한히 추가하는 것을 방지한다.

<br/>언마운트개념과는 차이가 있다. `언마운트`는 **특정 컴포넌트가 DOM에서 사라진다는 것을 의미**하는 클래스형 컴포넌트의 용어. `클린업 함수`는 언마운트보다는 함수형 컴포넌트가 리렌더링됐을 때 **의존성 변화가 있으면 당시 이전의 값을 기준으로 실행되는 함수**이다.

<br/>

<br/>

#### 🔸 의존성 배열

보통 빈 배열이거나 원하는 값을 넣을 수 있다, 빈배열을 넘기면, 최초 렌더링 직후에 실행된 다음 더 이상 실행하지 않는다. <br/>아무런 값도 넘기지 않으면, 의존성 비교를 할 필요가 없다고 판단해 렌더링 이 발생할 때 마다 실행된다. 보통 컴포넌트가 렌더링 됐는지 확인할 때 사용.

<br/>

##### 의존성 배열이 없는 useEffect와 useEffect없이 사용한 경우의 차이

```jsx
function Component(){ console.log('render 완료') }

function Component(){
  useEffect(()=>{
    console.log('render 완료')
  })
}
```

* SSR관점에서 useEffect는 클라이언트 사이드에서 실행되는 것을 보장해준다.
* useEffect는 컴포넌트 렌더링의 부수효과, 즉 컴포넌트의 렌더링이 완료된 이후 한번만 실행된다.<br/>직접 실행은 컴포넌트가 렌더링 되는 도중에 실행된다.
* 전자의 경우 SSR경우에 서버에서도 실행되지만, 이 작업은 함수형 컴포넌트의 반환을 지연시키게 된다.

❗ 잊지말자. `useEffect`는 **컴포넌트가 렌더링된 후**에 어떠한 **부수 효과를 일으키고 싶을 때 사용하는 훅**이다.

<br/>

#### 🔸 useEffect의 구현

(이 또한 마찬가지로, 비슷하게 구현한 코드이다.)

```javascript
const MyReact = (function(){
  const global = {}
  let index = 0;
  
  function useEffect(callback, dependencies){
    const hooks = global.hooks
    
    // 이전 훅 정보 확인
    let prevDependencies = hooks[index];
    
    // 변경됐는지 확인
    // 이전 값이 있다면 이전 값을 "얕은 비교"로 비교하여 변경 확인
    // 이전 값이 없다면 최초 실행이므로 변경이 일어난 것으로 간주해 실행을 유도.
    let isDependeciesChanged = prevDependencies 
    	? dependencies.some((value, idx)=> !Object.is(value, prevDependencies[idx]))
    	: true
    
    // 변경이 일어낫다면 첫째 인수인 콜백함수를 실행
    if(isDependenciesChanged) callback();

    // 현재 의존성을 훅에 다시 저장
    hooks[index] = dependencies
    
    // 다음 훅이 일어날 때를 대비하기 위해 index 추가
    index++
  }
  return {useEffect}
})
```

핵심은 **의존성 배열의 이전 값과 현재값의 얕은 비교**다.

리액트는 값을 비교할 때 `Object.is`를 통해 얕은 비교를 수행한다.

<br/>

#### 🔸 useEffect를 사용할 때 주의할 점

* eslint-disable-line react-hooks/exhaustive-deps 주석은 최대한 자제
* useEffect의 첫 번째 인수에 함수명을 부여하라
* 거대한 useEffect를 만들지 마라
* 불필요한 외부 함수를 만들지 마라

<br/>

##### eslint-disable-line react-hooks/exhaustive-deps 주석은 최대한 자제.

ESLint룰은 useEffect인수 내부에서 사용하는 값 중 의존성 배열에 포함돼 있지 않은 값이 있을 때 경고를 발생시킨다.

정말 필요할때는 사용할 수 있지만, 대부분 의도치 못한 버그를 만들 가능성이 크다. (대부분 빈배열로 의존성줄 때)

`useEffect`는 반드시 의존성 배열로 전달한 값의 변경에 의해 실행되야 하는 훅이다. 그러나 의존성 배열을 넘기지 않은 채 콜백 함수 내부에서 특정 값을 사용한다는 것은 이 부수효과가 실제로 관찰해서 실행돼야 하는 값과는 별개로 동작한다는 것을 의미한다. <br/>useEffect에서 사용한 콜백 함수의 실행과 내부에서 사용한 값의 실제 변경 사이에 연결고리가 끊어져 있는것이다.

정말로 의존성으로 []가 필요하다면, 최초에 함수형 컴포넌트가 마운트 됐을 시점에만 콜백함수 실행이 필요한지 다시생각해보고, "그렇다"라고 한다면 정말 그 위치에서 사용되는게 맞는지 생각해봐야한다.

<br/>

##### useEffect의 첫 번째 인수에 함수명을 부여하라

많은 코드에서 익명함수를 첫 번째 인수로 전달한다.<br/>useEffect의 수가 적거나 복잡성이 낮다면 상관없지만, 반대라면 어떤게 useEffect코드인지 파악하기 어렵다.

익명함수가 아닌 적절한 이름으로 바꾸는 것이 좋다.

<br/>

##### 거대한 useEffect를 만들지 마라

`useEffect`는 의존성 배열을 바탕으로 렌더링 시 의존성이 변경될 때 마다 부수 효과를 실행한다.<br/>그렇기 때문에 부수 효과가 커질 수록 애플리케이션에 악영향을 끼칠 것이다.

만약 부득이 하게 useEffect가 커져야 한다면, 적은 의존성 배열을 사용하는 여러개의 useEffect로 분리하는 것이 좋다.

<br/>

##### 불필요한 외부 함수를 만들지 마라.

useEffect가 실행하는 콜백함수 역시 불필요하게 존재하면 안된다.

props를 받아 그 정보를 바탕으로 api를 호출하는 useEffect를 구현한 코드이다. 2가지 코드를 보자.

```tsx
// 1
function Component({id}: {id: string}){
  const [info, setInfo] = useState<number | null>(null)
  const controllerRef = useRef<AbortController | null>(null)
  const fetchInformation = useCallback(async (fetchId: string)=>{
    controllerRef.current?.abort();
    controllerRef.current = new AbortController();
    
    const result = await fetchInfo(fetchId, {signal: controllerRef.signal});
    setInfo(await result.json())
  }, [])
  
  useEffect(()=>{
    fetchInformation(id)
    return ()=>controllerRef.current?.abort()
  }, [id, fetchInformation])
  ...
}
```

```tsx
// 2
function Component({id}: {id: string}){
  const [info, setInfo] = useState<number | null>(null)
  
  useEffect(()=>{
    const controller = new AbortController();
    (async()=>{
      const result = await fetchInfo(fetchId, {signal: controllerRef.signal});
      setInfo(await result.json())
    })();
    return ()=>controller.abort();
  }, [id])
  ...
}
```

2번이 useEffect외부에 있던 관련 함수를 내부로 가져와 훨씬 간결해진 모습을 볼 수 있다.

불필요한 의존성 배열을 줄이고, 무한 루프에 빠지지않게 하기 위해 작성한 useCallback도 삭제할 수 있었다.

<br/>

> **왜 useEffect의 콜백인수로 비동기 함수를 바로 넣을 수 없을까?**
>
> useEffect내부에서 state를 결과에 따라 업데이트 하는 로직이 있다고 가정해보자. 만약, 비동기함수가 사용가능하다면 비동기 함수의 응답속도에 따라 결과가 이상하게 나타날 수도 있다.
>
> <br/>
>
> **useEffect의 경쟁 상태(race condition)**
>
> 이전 state기반의 응답이 10초가 걸리고 이후 바뀐 state기반 응답이 1초뒤에 왔다면 이전 state기반으로 결과가 나와버리는 불상사가 생길 수 있다.
>
> <br/>
>
> 한 가지 유의할 점은 비동기함수를 지정할 수 없는 것이지 실행자체가 문제되는 것은 아니다. 다만, useEffect내부에서 비동기 함수가 생성되고 실행되는 것을 반복하므로 클린업 함수에서 이전 비동기 함수에 대한 처리를 추가하는 것이 좋다.
>
> 정리하자면, `비동기 useEffect`는 state의 경쟁상태를 야기할 수 있고 cleanup함수의 실행순서도 보장할 수 없기 때문에 개발자의 편의를 위해 useEffect에서 비동기 함수를 인수로받지 않는다.

<br/>

### 👉 3.1.3 useMemo

`useMemo`는 비용이 큰 연산에 대한 결과를 저장해두고, 이 **저장된 값을 반환하는 훅**이다. (값뿐만아니라 컴포넌트도 가능)

`useMemo`는 렌더링 발생 시 의존성 배열의 값이 변경되지 않았으면 함수를 재실행하지 않고, 이전에 기억해둔 해당 값을 반환하고, 의존성 배열의 값이 변경됐다면 첫 번째 인수의 함수를 실행한 후에 그 값을 반환하고 다시 그 값을 기억한다.

`useMemo`로 컴포넌트도 감쌀 수 있지만, `React.memo`를 사용하는 것이 더 현명하다.

이전에 `2.5장`에서 봤었던 어떤 경우 메모이제이션 하는 것이 좋을지에 대한 것을 참고하여 사용하면 된다.

<br/>

### 👉 3.1.4 useCallback

`useMemo`는 값을 기억했다면, `useCallback`은 인수로 받은 콜백을 기억한다.<br/>즉, **특정 함수를 새로 만들지 않고 재사용 한다**는 것이다. 

memo를 사용해 컴포넌트를 메모이제이션 해도, App의 자식 컴포넌트 전체가 렌더링 된다. <br/>자식 컴포넌트에 onChange같은 함수가 있다면, 리렌더링될때 이 함수가 재생성 된다.<br/>(크롬 메모리 프로필에서도 확인이 가능.)

useCallback을 추가하면 해당 의존성이 변경됐으르 떄만 함수가 재생성 되는 것을 볼 수 있다.<br/>❗ **함수의 재생성을 막아 불필요한 리소스 또는 리렌더링을 방지하고 싶을 때 useCallback을 사용**.

> 왜 useCallback에 기명함수를 넣는가?
>
> 대부분 익명함수로 첫 번째 인수를 넘겨주는데, 크롬 메모리 탭에서 디버깅을 용이하게 하기 위해서 기명함수를 사용한다.<br/>익명함수를 사용하면 함수를 추적하는데 어려움이 있다. (7장에서 자세히)

Preact에서 useCallback을 useMemo를 사용해 구현한 것을확인할 수 있다. (링크 참고)

<br/>`useMemo`와 `useCallback`의 유일한 차이는 메모이제이션을 하는 대상이 변수냐 함수냐의 차이 분이다.

JS에서는 함수 또한 값으로 표현될 수 있으므로 이런 코드가 매우 자연스러운데, useMemo로 useCallback을 구현하는 경우 불필요하게 코드가 길어지고 혼동을 야기하기때문에 별도로 제공하는 것으로 추측된다.

<br/>

### 📘 참고

* [Preact - useMemo를 사용한 useCallback 구현](https://bit.ly/475LmOv)

<br/>

### 👉 3.1.5 useRef

`useRef`는 `useState`와 동일하게 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장한다는 공통점이 있다.

**차이점**

* `useRef`는 반환값인 객체 내부에 있는 current로값에 접근 또는 변경할 수 있다.
* `useRef`는 그 값이 변하더라도 렌더링을 발생시키지 않는다.

❗ `useRef`로 `useState`를 흉내내도 렌더링이 되지 않는다.

<br/>

> 왜 필요할까?
>
> 렌더링에 영향을 미치지 않는 고정된 값을 관리하기 위해 useRef를 사용한다면 useRef를 사용하지 않고 `그냥 함수 외부에서 값을 선언해서 관리하는 것도 동일한 기능을 수행할 수도 있지 않을까?`
>
> ```jsx
> let val = 0;
> function Component(){
> 	function handleClick(){
>     val+=1
>   }
>   ...
> }
> ```
>
> 이 방식은 몇 가지 단점이 있다.
>
> * 먼저 컴포넌트가 실행되어 렌더링되지 않았음에도 value라는 값이 존재하게 된다. <br/>=> 메모리에 불필요한 값을 갖게 하는 악영향을 미친다.
> * Component가 여러번 생성된다면, 각 컴포넌트에서 가리키는 값이 모두 value로 동일해져 버린다.

`useRef`는 이 2가지 단점을 극복할 수 있다. 컴포넌트가 렌더링 될떄만 생성되고, 인스턴스가 여러개라도 각각 별개의 값을 바라본다.

❗ `useRef`의 최초 기본값은 DOM이 아니고, useRef로 넘겨받은 인수다. <br/>=> useRef가 선언된 당시에는 컴포넌트가 렌더링 되기 전이라 return으로 컴포넌트의 DOM이 반환되기 전이기 때문에 `undefined`이다.

<br/>

`useRef`를 사용할 숭 ㅣㅆ는 유용한 경우는 렌더링을 발새이키지 않고 원하는 상태값을 저장할 수 있다는 특징을 활용해 `useState`의 이전 값을 저장하는 `usePrevious()`같은 훅을 구현할 때다.

```jsx
function usePrevious(val){
  const ref = useRef();
  useEffect(()=>{
    ref.current = val
  },[val])
  return ref.current
}

function SomeComponent() {
  const [counter, setCounter] = useState(0);
  const previouscounter = usePrevious(0);
  function handleClick(){ setCounter((prev)=> prev+1}
	
	// 0 undefined	
	// 1 0
  // 2 1
	// ...
}
```

이렇게 원하는 시점의 값을 렌더링에 영향을 미치지 않고 보관해 두고 싶을 떄 useRef를 사용하는 것이 좋다.

**Preact에서 useRef**

```javascript
export function useRef(initialValue){
  currentHook = 5;
  return useMemo(()=>({current: initialvlaue}), [])
}
```

값이 변경되도 렌더링이 되면 안된다는 점, 실제 값은 `{current: value}`와 같은 객체 형태로 있다는 점을 떠올리자.

렌더리엥 영향을 미치면 안되기 때문에 `useMemo`에 의도적으로 빈 배열을 선언해 뒀고, 이는 각 렌더링마다 동일한 객체를 가리키는 결과를 낳을 것이다.