# 🐳 01. 리액트 개발을 위해 꼭 알아야 할 자바스크립트

## 🌏 1.1. 자바스크립트의 동등 비교

리액트 함수형 컴포넌트와 훅을 반복적으로 작성하다 보면 의존성 배열(dependencies)에 고민해본 적이 있을 것이다. 보통은 `eslint-react-config`에 선언돼 있는 `react-hooks/exhaustive-deps`의 도움을 받아 해당 배열을 채우곤 하는데, **실제로 이것이 어떤식으로 동작하고, 왜 이런 변수들을 넣어야 하는지 모르는 경우**가 많다.

렌더링 관점에서도 살펴볼만한 이유가 있다. **리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 바로 props의 동등 비교에 따른 결과**다.<br/>props의 동등비교는 객체의 얕은 비교를 기반으로 이뤄지는데, 얕은 비교가 어떻게 작동는지 모르면, 렌더링 최적화에 어려움을 겪을 수 있다.

❗ 리액트의 `가상DOM과 실제 DOM의 비교`, `리액트 컴포넌트가 렌더링 할지를 판단하는 방법`, `변수나 함수의 메모제이션` 등 모든 작업은 **자바스크립트의 동등 비교**를 기반으로한다.

### 👉 1.1.1 자바스크립트의 데이터 타입.

크게 `원시타입`과 `객체타입`으로 나뉜다.

| 원시 타입                                                | 객체 타입                                                    |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| boolean, number, string, null, undefined, symbol, bigint | object (배열, 함수, 정규식, 클래스 등, **원시타입 이외의 것**) |





### 👉 1.1.2 값을 저장하는 방식의 차이

원시타입과 객체타입의 가장 큰 차이는 **값을 저장하는 방식**이다. => 동등 비교를 할 때 차이를 만든다.



**원시타입**

변수 할당 시점에 메모리 영역을 차지하고, 불변 형태의 값으로 저장된다.

```javascript
// 1
let hello = 'hello world';
let hi = hello;
console.log(hello === hi); // true
// 2
let hello = 'hello world';
let hi = 'hello world'
console.log(hello === hi); // true
```

1의 경우, hello의 hello world라는 값이 hi에 복사해 전달 됐기 때문에 true가 나온다. 값을 비교하므로 값을 전달하는 방식이 아닌 각각 선언하는 방식(2번)으로도 같은 결과를 볼 수 있다.



**객체 타입**

객체는 프로퍼티를 추가, 수정, 삭제할 수 있어 원시 값과 다르게 **변경 가능한 형태로 저장**되며, 값을 복사할 때도 값이 아닌 **참조를 전달**한다.

```javascript
// 다음 객체는 동일한 내용을 가짐.
var hello = { greet: 'hello, world'}
var hi ={ greet: 'hello, world' }

// 동등 비교시 false가 나오고, 원시값인 내부 속성값을 비교하면 동일하다.
console.log(hello===hi); // false
console.log(hello.greet===hi.greet); // true
```

동일하게 선언했던 객체라도 저장하는 순간 다른 참조를 바라보기 때문에 false를 리턴한다.



``` javascript
var hello={ greet: 'hello, world'};
var hi = hello;

console.log(hello===hi); // true
```

이 에제에서 hello와 hi는 변수명 및 변수명의 주소는 다르지만, **value가 가리키는 주소가 동일**하여 true를 반환한다.

❗ 항상 객체간의 비교가 발생하면, 이 객체 간의 비교는 우리가 이해하는 내부의 값이 같더라도 결과는 대부분 true가 아닐 수 있음을 인지해야 한다.



### 👉 1.1.3 자바스크립트의 또 다른 비교 공식, Object.js

`Object.is`는 두 개의 인수를 받아 이 인수 두 개가 동일한지 반환하는 메서드다.

>  **==과 Object.is**
>
> ==비교는 강제형변환 후에 변경하지만, Obejct.is는 ===과 동일하게 타입이 다르면 false다.
>
> <br/>
>
> **===과 Object.is**
>
> `Object.is`가 좀 더 개발자가 기대하는 방식으로 비교를 하는 것을 볼 수 있다.
>
> ```javascript
> -0 === +0 // true
> Object.is(-0, +0) // false
> 
> Number.NaN === NaN // false
> Object.is(Number.NaN, NaN) // true
> 
> NaN === 0/0 // false
> Object.is(NaN, 0/0) // true
> ```

객체 비교에는 Object.is도 크게 차이가 없다.

```javascript
Object.is({}, {}) // false

const a = {hello: 'hi'}
const b = a;

Object.is(a,b) // true
a===b; // true
```



### 👉 1.1.4 리액트에서 동등 비교

리액트에서 동등비교는 `Object.is`로 이루어진다.<br/>`Object.is`는 ES6에서 제공하는 기능이므로 리액트에서는 이를 구현한 폴리필(Polyfill)을 함꼐 사용한다.

**리액트의 값을 비교하는 objectIs.**

```javascript
// flow로 구현돼 있어 any가 추가돼 있다. flow에서 any는 ts와 동일하게 어떤 값도 받을 수 있는 타입.
function is(x: any, y: any) {
  return (
    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare
  );
}

// 런타임에서 Object.is가 있다면, 그것을 사용하고 아니면 위 함수를 사용한다.
const objectIs: (x: any, y: any) => boolean =
  typeof Object.is === 'function' ? Object.is : is;

export default objectIs;
```



리액트에서는 위 함수를 기반으로 동등 비교를 하는 **shallowEqual**이란 함수를 만들어 사용한다.

**shallowEqual**

```javascript
import is from './objectIs';
import hasOwnProperty from './hasOwnProperty';

// 주어진 객체의 키를 순회하면서 두 값이 엄격한 동등성을 가지는지 확인하고, 다른 값이 있다면 false 반환.
// 두 객체 간에 모든 키 값이 동일하면, ture 반환
function shallowEqual(objA: mixed, objB: mixed): boolean {
  if (is(objA, objB)) {
    return true;
  }

  if (
    typeof objA !== 'object' ||
    objA === null ||
    typeof objB !== 'object' ||
    objB === null
  ) {
    return false;
  }

  // 각 키 배열
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  // 배열길이가 다르면 false
  if (keysA.length !== keysB.length) {
    return false;
  }

	// A키를 기준으로 B에 같은 키가 있는지, 값이 있는지 확인.
  for (let i = 0; i < keysA.length; i++) {
    const currentKey = keysA[i];
    if (
      !hasOwnProperty.call(objB, currentKey) ||
      !is(objA[currentKey], objB[currentKey])
    ) {
      return false;
    }
  }

  return true;
}

export default shallowEqual;
```



❗ 정리하자면, 리액트에서는 Object.is로 먼저 비교를 수행한 다음에 Object.is로 수행하지 못하는 비교, 즉 객체 간 얕은 비교를 한 번 더 수행하는 것을 알 수 있다.

1depth까지는 한 번 더 비교를 한다.

```javascript
Object.is({hello:'world'}, {hello:'world'}) // false
shallowEqual({hello:'world'}, {hello:'world'}) // true
shallowEqual({hello:{'hi': 'world'}}, {hello:{'hi': 'world'}}) // false
```



#### 왜 얕은 비교까지만 할까?

리액트에서 사용하는 **JSX props는 객체**이고, **props만 일차적으로 비교하면 되기 때문**이다.

내부에 있는 객체까지 완벽히 비교하기 위해서 재귀문가지 넣었다면, 객체안에 객체가 몇 개까지 있을지 알 수 없으므로 이를 **재귀적으로 비교하려 할 경우 성능에 악영향을 미칠 것**이다.



### 📘 참고

* [React Git - objectIs 함수](https://github.com/facebook/react/blob/main/packages/shared/objectIs.js)
* [React Git - shallowEqual 함수](https://github.com/facebook/react/blob/main/packages/shared/shallowEqual.js)





## 🌏 1.2 함수

먼저 함수의 형태와 차이점을 알아보자.

### 👉 1.2.1 함수란 무엇인가?

JS에서 **함수**란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고 이를 **하나의 블록으로 감싸 실행 단위로 만들어 놓은 것**.

리액트에서도 Compoennt라는 함수를 선언하고, 매개변수로 props를 받아 return문으로 JSX를 반환한다.

```javascript
function sum(a,b){
  return a+b;
}

function Component(props){
  return <div>{props.hello}</div>
}
```



### 👉 1.2.2 함수를 정의하는 4가지 방법

#### 함수 선언문

가장 일반적으로 사용하는 방식으로 표현식이 아니라 일반 **문(statement)으로 분류** 된다.

❗ 표현식은 무언가 값을 산출하는 구문을 의미하지만, 위의 함수 선언으로는 어떤 값도 표현되지 않았으므로 문으로 분류된다.

```javascript
function add(a,b){
  return a+b
}
```



#### 함수 표현식

```javascript
const sum = function (a,b) {
  return a+b
}
```

자바스크립트 함수는 **일급객체**다.

> 일급 객체
>
> 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체. <br/>다른 함수의 매개변수가 될 수 있고, 반환값이 될수 있고, 할당도 가능하다.



function뒤에 이름은 함수 내에서만 유효한 식별자이기 때문에 외부에서 호출할 수 없다. 그래서 혼란을 방지하기 위해 생략하는 것이 일반적이다.

> **❗ 표현식과 선언식의 차이**
>
> 가장 큰 차이는 **호이스팅 여부**다. 
>
> 표현식의 경우 호이스팅이 발생하여, 표현식 이전에 함수 실행이 가능하다. <br/>선언식의 경우 변수에 함수를 할당하므로, 변수의 호이스팅은 발생한다. 그러나 함수는 할당되지 않기 때문에 사용이 불가능하다.



#### Function 생성자

```javascript
const add = new Function('a', 'b', 'return a+b')
```

함수 내용을 모두 문자열로 작성하여, 코드양이 길면 혼란스러워 진다. 또, 생성자 방식으로 함수 생성시 클로저 또한 생성되지 않는다. 

이 방법은 권장되지 않는다.



#### 화살표 함수

```javascript
const add = (a,b) => {
  return a+b;
}
```

화살표 함수에서는 **constructor를 사용할 수 없다**.

화살표 함수에서는 **arguments가 존재하지 않는다**.



일반함수와 가장 큰 차이는 **this바인딩**이다. <br/>( 이 차이로 인해 클래스형 컴포넌트에서 이벤트 바인딩할 메서드 선언 시 화살표 함수로 했을 때와 일반 함수로 했을때 다르게 동작한다. )

> this
>
> this는 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값.
>
> 이전에는 **함수가 어떻게 호출되느냐에 따라 동적으로 결정**된다.
>
> **화살표 함수는 함수 자체 바인딩을 갖지 않는다.** 화살표 함수 내부의 this는 상위 스코프의 this를 그대로 따른다.



### 👉 1.2.3 다양한 함수 살펴보기

리액트에서 자주 사용하는 방식만 알아보자.



#### 즉시 실행 함수 (Immediately Invoked Function Expression, IIFE)

단 한번만 호출하고 다시 호출할 수 없는 함수.

```javascript
((a,b)=> {return a+b})(a,b)
```

* 재호출이 되지않아 이름을 붙이지 않는다.
* 코드 읽을 때 다시 호출되지 않는다는 점을 각인시켜 리팩터링에 도움.



#### 고차함수 (Higher Order Function)

함수는 일급객체이므로 함수를 인수로 받거나 새로운 결과로 리턴할 수 있다.

```javascript
const add = function(a){
  // a가 존재하는 클로저 생성
	return function (b){
    // b를 인수로 받아 두 합을 반환하는 또 다른 함수 생성
		return a+b
  }
}
add(1)(3)
```

이와 유사하게 함수형 컴포넌트를 인수로 받아 함수형 컴포넌트를 리턴하는 **고차 컴포넌트(Higher Order Component)**개념도 있다.



### 👉 1.2.4 함수를 만들 때 주의사항

#### 함수의 부수효과(side-effect)를 최대한 억제하라.

함수 내의 동작으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것을 의미하며, 이처럼 부수 효과가 없는 함수를 **순수 함수**, 부수 효과가 있는 함수를 **비순수 함수**라고 한다.  

❗ `순수 함수`는 언제 어느 상황에서도 동일한 인수를 받으면 동일한 결과를 받아야하고, 외부에 어떤 영향도 끼쳐서는 안된다. 그렇기 때문에 항상 결과가 동일하여 예측 가능하며 **안정적이란 장점**이 있다. <br/>하지만 항상 순수 함수로만 작성할 필요는 없다. => API호출의 경우 외부 영향(HTTP request)을 끼치기 때문에 부수효과이다.

즉, 부수 효과를 최소화하고, 함수의 실행과 결과를 최대한 예측 가능하도록 설계하도록 한다.



#### 가능한 한 함수를 작게 만들어라.

ESLint의 표현을 보자면, 함수의 코드길이가 길어질 수록, 문제가 일어날 확률이 커지고, 내부에서 추적이 어려워진다. 따라서 50줄이상이 되면 과도하게 커졌다고 생각해 경고 메세지를 출력한다.

❗ 함수의 원래 목적인 재사용성을 높이기 위해 하나의 일을 하나만 잘하도록 작성하자.



#### 누구나 이해할 수 있는 이름을 만들어라

코드가 길어지거나 애플리케이션이 커질 수록, 함수의 일므은 간결하고 이해하기 쉽게 붙이는 것이 좋다.