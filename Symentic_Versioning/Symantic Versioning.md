

# 🐳 Semantic Versioning (SemVer)

📘 [semver.org](https://semver.org/spec/v2.0.0.html)

## 🌏 요약

`SemVer`은 그라비타의 창시자이자 깃헙의 공동창업자인 [톰 프레스턴-베르너(Tom Preston-Werner)](http://tom.preston-werner.com/)가 작성하였으며, 어떻게 버전 번호를 정하고 올려야 하는지를 명시하는 규칙과 요구사항을 제안하며, **버전 번호를 올리는 방식으로 어떻게 API가 변하는지 표현**한다.

<BR/>

❗ **[MAJOR].[MINOR].[PATCH]**

1. **MAJOR** : 기존 버전과 호환되지 않게 API가 바뀌는 경우
2. **MINOR** : 기존 버전과 호환되면서 새로운 기능을 추가할 때
3. **PATCH** : 기존 버전과 호환되면서 버그를 수정한 것

<BR/><BR/>

## 🌏 규칙

여기서 사용하는 표현들은 [RFC 2119](http://tools.ietf.org/html/rfc2119)에 기술한 대로 해석.

“MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL”

1. SemVer을 사용하는 소프트웨어는 **반드시 공개 API를 선언**해야한다. (`MUST`)<br/>반드시 코드 자체로 선언하거나 문서로 엄격히 명시해야 하며, 어떤 방식으로든 **정확하고 이해하기 쉬워**야 한다.(`SHOULD`)
2. 보통 버전 번호는 반드시 `X.Y.Z`형태로 각각 자연수이어야 한다.. (절대로 0이 앞에 붙어서는 안된다.`MUST NOT`)<BR/>1.10.0 -> 1.11.0 이렇게 반드시 증가하는 수여야 한다.(`MUST`)
3. 특정 버전으로 패키지를 배포하고 나서는 그 버전의 내용은 바뀌면 안되며(`MUST NOT`), 변경분은 반드시 새로운 버전으로 배포.(`MUST`)
4. MAJOR `0.X.Y`형태로 0으로 시작하는 것은 초기 개발을 위해 사용하며, 아무때나 바꿀 수 있으니 안정판으로 보지 않는게 좋다.
5. PATCH가 수정되는 것은 반드시 그전 버전 API와 호환되는 버그 수정의 경우에만 올린다.(`MUST`) <BR>여기서 버그는 잘못된 내부 기능을 고치는 것이라 정의한다.
6. 기존 버전과 호환되는 새로운 기능을 추가할 때는 반드시 MINOR를 올린다. (`MUST`)
   * API의 일부를 앞으로 제거할 것(deprecate)하는 경우에도 반드시 올린다. (`MUST`)
   * 내부 비공개 코드에 새로운 기능이 대폭 추가되거나 개선사항이 있을 때도 올린다.(`MAY`)
   * MINOR를 올린후 PATCH는 반드시 0부터 다시 시작한다.(`MUST`)
7. 기존 API와 호환되지 않는 변화가 있다면 반드시 MAJOR를 올린다. 이때 역시 MINIOR와 PATCH는 0부터 시작한다.(`MUST`)
8. PATCH뒤에 붙임표(`-`)를 붙이고 마침표(`.`)로 구분되는 식별자를 더해서 정식 배포를 앞둔 (pre-release)버전을 표기할 수 있다.
   * 식별자는 반드시 아스키문자, 숫자, 붙임표로만 구성해야 하며 한글자 이상이어야 한다.. ([0-9A-Za-z-]) (`MUST`)
   * 숫자 식별자의 경우 앞에 0을 붙인 숫자로 표기하지 않는다. (`MUST NOT`)
   * ex) 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
9. 빌드 메타데이터는 PATCH나 정식 배포 전 식별자 뒤에 더하기(+)부호를 붙인 뒤에 마침표로 구분된 식별자를 덧붙여서 표현할 수 있다. 
   * 식별자는 반드시 아스키 문자와 숫자와 붙임표로만 구성한다. ([0-9A-Za-z-]) 
   * 식별자는 반드시 한글자 이상이어야 하며, 빌드 메타데이터는 버전 간의 우선순위를 판단하고자 할 때 반드시 무시해야한다. (`MUST`)
   * 즉, 빌드 메타데이터만 다른 두 버전의 우선순위는 같다.
   * ex) 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
10. 우선 순위는 버전의 순서를 정렬할 때 서로를 어떻게 비교할 지 나타낸다. 아래와 같이 차이가 발견될 때까지 점으로 구분된 각 식별자를 왼쪽에서 오른쪽으로 비교해 결정 (**빌드 메타데이터는 우선 순위에 영향을 주지 않는다.**)
    1. 숫자로만 구성된 식별자는 숫자로 비교됩니다.
    2. 문자나 하이픈이 포함된 식별자는 ASCII 정렬 순서에 따라 어휘적으로 비교됩니다.
    3. 숫자 식별자는 항상 숫자가 아닌 식별자보다 우선순위가 낮습니다.
    4. 이전 식별자가 모두 동일한 경우 더 큰 시험판 필드 집합이 더 작은 집합보다 우선 순위가 높습니다.
    5. Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0

<br/><br/>

## 🌏 FAQ

(일부 faq만 가져옴.)

### 👉 Q. 초기 개발 단계에서 0.y.z 버전관리는 어떻게?

가장 간단한 방법은 최초 개발 배포를 0.1.0으로 하고, 이후 배포마다 부버전을 올리는 것

### 👉 언제 1.0.0을 배포해야 할지 어떻게 알 수 있나?

실 서비스에 쓰이기 시작했다면 이미 1.0.0이다. 사용자들이 믿고 쓸 수 있는 안정한 API가 있다면 1.0.0이며 하위 버전 호환성이 우려되기 시작한다면 이미 1.0.0일 수 있다.

### 👉MAJOR 버전을 올리는데 실수로 호환되지 않는 변경이 들어갔다면?

즉시 문제를 해결하고 호환성이 깨진부분을 복구하여 새 MAJOR버전을 배포한다.

이런 경우에도 이미 배포된 버전을 변경해서는 안되며, 필요한 경우 문제가 되는 버전을 문서로 표시해서 사용자들로 하여금 주의하도록 한다.

### 👉 PUBLIC API는 유지한 채 내부의 의존성을 바꾼다면 어떻게 해야하나?

PUBLIC API에 영향을 주지 않으니 호환된다고 여기지만, 별도로 의존성 명세가 있어야 하며, 사용자가 충돌을 눈치 챌 것이다.

변화가 PATCH버전 수준인지 MAJOR버전 수준인지 결정하는 것은 버그를 수정하고자 한 작업인지, 새로운 기능을 추가하기 위해서인지에 달려있다. 후자의 경우, 추가적인 코드를 예상할 것이며, 그렇다면 당연히 MAJOR버전을 증가해야 할 것이다

### 👉 실수로 버전 증가와 맞지 않게 PUBLIC API를 변경 했다면?  (PATCH 배포에서 잘못된 코드가 들어가 깨지는 경우)

스스로 최선을 판단하자.

원래 의도했던 대로 사용될 수 있게 바꾸는 작업에 영향을 받는 대규모 사용자층이 있다면, 수정사항이 엄밀히 따지자면 PATCH버전 배포로 여겨져야 한다 하더라도 MAJOR버전 배포를 하는 것이 최선일 것이다.

변경이 사용자에게 중요한 의미가 있다면 버전 번호로 잘 알릴 수 있도록 하자.

❗ SemVer은 어떻게 버전 번호가 바뀌는지 의미를 전달하는 것이 전부임을 잊지말자.

### 👉 제거하는 기능들에 대해서는?

1. 문서를 업데이트해서 사용자들에게 변화를 알리도록 한다.
2. 해당 기능이 제거될 거라 표시된 새 부버전을 적절한 시기에 배포한다.

새로운 MAJOR 버전에서 완전히 기능을 제거하기 전에 제거 될 것이라 표시한 MINOR버전 배포를 최소한 한 번은 진행하여 원활하게 새 API를 사용하도록 한다.

### 👉 버전 문자열 길이의 제한

길이 제한이 따로 없지만 255자 버전 문자열은 지나치게 길 것이다. 알아서 잘 판단.

### 👉 SymVer을 판단할 수 있는 정규식(RegEx)가 있는가?

1. 캡처 그룹 이름 지정 방식의 정규식 

   * ([Perl Compatible Regular Expressions,즉 Perl, PHP and R], Python, Go 지원)

   * https://regex101.com/r/Ly7O1x/3/

   * ```text
     ^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
     ```

2. 캡처 그룹 이름 지정 방식을 지원하지 않는 경우의 정규식

   * 대신 **ECMA 스크립트(JavaScript)**, **PCRE**(Perl Compatible Regular Expressions, 즉 Perl, PHP)와 **호환되는 번호가 매겨진 캡처 그룹**(예: cg1 = 메이저, cg2 = 마이너, cg3 = 패치, cg4 = 시험판 및 cg5 = 빌드메타데이터)이 있는 것입니다. 및 R), Python 및 Go.

   * https://regex101.com/r/vkijKf/1/

   * ```text
     ^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
     ```

   

   



