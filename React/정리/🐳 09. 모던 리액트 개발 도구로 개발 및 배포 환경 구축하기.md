# 🐳 09. 모던 리액트 개발 도구로 개발 및 배포 환경 구축하기

## 🌏 09-01. Next.js로 리액트 개발 환경 구축하기

`cra`나 `cna`는 각각 애플리케이션을 손쉽게 만들기 위한 CLI 도구다. <br/>편리하지만, 프로젝트 구조를 공부하고 이해하는데는 크게 도움되지 않는다. 뿐만아니라 cra의 경우 이제 더이상 업데이트 되지 않는다.

<br/>

### 👉 09-01-01. create-next-app없이 하나씩 구축하기

가장 먼저 할 일은 `package.json`을 만드는 것이다. 그 후 필요한 `react`, `react-dom`, `next` 그리고 타입 지원에 필요한 파일들과 lint를 설치하자.

```shell
npm init
npm i react react-dom next
npm i @types/node @types/react @types/react-dom eslint eslint-config-next typescript --save-dev
```

<br/>

### 👉 09-01-02. tsconfig.json 작성하기

 `tsconfig`는 타입스크립트 설정을 기록한다.

```json
{
  "$schema": "https://json.schemastore.org/tsconfig.json"
}
```

`$schema`값은 schemaStore에서 제공해주는 정보로 해당 JSON파일이 무엇을 의미하고, 또 어떤 키와 값이 들어갈 수 있는지 알려주는 도구다. `$scheam`와 올바른 값이 선언돼 있다면 VSCode 나 웹스톱같은 IDE에서 자동완성이 가능해진다.

```json
{
  "$schema": "https://json.schemastore.org/tsconfig.json",
  "compilerOptions": {
    "target": "es5", // 타입스크립트가 변환을 목표로 하는 언어의 버전
    "lib": ["dom", "dom.iterable", "esnext"], 
    "allowJs": false, // 타입스크립트가 자바스크립트도 지원을 할지 
    "skipLibCheck": true, // 라이브러리에서 제공하는 d.ts에 대한 검사 여부를 결정.
    "strict": true, // 엄격 모드
    "forceConsistentCasingInFileNames": true, // 파일 이름의 대소문자를 구분하도록 강제함.
    "noEmit": true, // 컴파일 하지 않고, 타입체크만 진행.
    "esModuleInterop": true, // CommonJS방식으로 보낸 모듈을 ES모듈방식의 import로 가져올 수 있게 해준다.
    "module": "esnext", // 모듈 시스템을 설정. commmonjs - require와 esnext - import가 대표적이다.
    "moduleResolution": "node", // 모듈을 해석하는 방식
    "resolveJsonModule": true, // JSON파일을 iport할 수 있게 해준다.
    "isolatedModules": true, // 타입스크립트 컴파일러는 파일에 import나 export가 없다면 단순 스크립트 파일로 인식해 이러한 파일이 생성되지 않도록 한다.
    "jsx": "preserve", // tsx파일 내부에 jsx를 어떻게 컴파일할지 설정
    "incremental": true, // 활성화 시 마지막 컴파일 정보를 .tsbuildinfo파일 형태ㅗㄹ 만들어 디스크에 저자한다.
    "baseUrl": "src", // 모듈을 찾을 때 기준이 되는 디렉터리를 지저아.
    "paths": { // 상대 경로에 대한 별칭을 지정
      "#pages/*": ["pages/*"],
      "#hooks/*": ["hooks/*"],
      "#types/*": ["types/*"],
      "#components/*": ["components/*"],
      "#utils/*": ["utils/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"], // 컴파일 대상에서 포함시킬 파일 목록을 의미
  "exclude": ["node_modules"] // 컴파일 대상에서 제외시킬 파일 목록을 의미.
}
```

<br/>

### 👉 09-01-03. next.config.js 작성하기

Next를 위한 설정

```js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  poweredByHeader: false,
  eslint: {
    ignoreDuringBuilds: true,
  },
}

module.exports = nextConfig
```

❗ `next.config.js`가 제공하는 설정 파일은 버전별로 조금씩 다르다.

* reactStrictMode : 리액트의 엄격 모드를 활성화 한다.
* poweredByHeader : 일반적으로 보약 취약점으로 취급되는 X-Powered-By헤더를 제거한다.
* eslint.ignoreDuringBuilds: 빌드시 ESLint를 무시한다. <br/>일반적으로 빌드 시 ESLint도 같이 수행하는데, true로 설정해 빌드시 ESLint를 수행하지 않게 했다. 이후에는 CI과정에서 별도로 작동하게 만들어 빌드를 더욱 빠르게 만들 것이다.

<br/>

### 👉 09-01-04. ESLint와 Prettier 설정하기

`eslint-config-next`는 단순히 코드에 있을 잠재적인 문제만 확인할 뿐, 띄어쓰기나 줄바꿈과 같은 코드의 스타일링을 정의해 주지 않는다. `@titicaca/eslint-config-triple`을 설치해 사용.

유념할 점은 `eslint-config-next`와 `eslint-config-triple`이 함께 작동하게 하려면 별도 설정이 필요하다.

```ts
const path = require('path')

const createConfig = require('@titicaca/eslint-config-triple/create-config')
const {extends: extendConfigs, overrides} = createConfig({
  type: 'frontend',
  project: path.resolve(__dirname, './tsconfig.json')
})

module.exports={
  extends: [...extendConfigs, 'next/core-web-vitals'],
  overrides
}
```

extends에 next/core-web-vitials를 추가하면 2가지 설정이 모두 적용된다. 이 외에도 `.eslintignore`, `.prettierignore`에 .next나node_modules를 추가해 정적 분석 대상에서 제외시킨다. 두 폴더는 개발자가 직접 작성하는 코드가 아니기 때문에 정적 분석할 필요가 없다.

<br/>

### 👉 09-01-05. 스타일 설정하기

`styled-components`를 사용해보자

```shell
npm i styled-components
```

swc에 styled-components를 사용한다는 것을 알리기 위해 `styledComponents: true`를 `next.config.js`에 추가<br/>-> swc가 styled-components를 사용하는 코드를 더 빠르게 변환한다.

추가적으로 `pages/_document.tsx`의 Head에 styled-components를 사용하기 위한 ServerStyledSheet를 추가.

```tsx
import Document, {
  Html,
  Head,
  Main,
  NextScript,
  DocumentContext,
  DocumentInitialProps,
} from 'next/document'
import { ServerStyleSheet } from 'styled-components'

export default function MyDocument() {
  return (
    <Html lang="ko">
      <Head />
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  )
}

MyDocument.getInitialProps = async (
  ctx: DocumentContext,
): Promise<DocumentInitialProps> => {
  const sheet = new ServerStyleSheet()
  const originalRenderPage = ctx.renderPage

  try {
    ctx.renderPage = () =>
      originalRenderPage({
        enhanceApp: (App) => (props) => sheet.collectStyles(<App {...props} />),
      })

    const initialProps = await Document.getInitialProps(ctx)
    return {
      ...initialProps,
      styles: (
        <>
          {initialProps.styles}
          {sheet.getStyleElement()}
        </>
      ),
    }
  } finally {
    sheet.seal()
  }
}
```

<br/>

### 👉 09-01-06. 애플리케이션 코드 작성

해당 코드는 `react-deep-dive-example-main/chapter7/zero-to-next`를 확인.

* pages : Next.js에서 예약어로 지정해두고 사용하는 폴더로, 하위 내용이 모두 라우터가 된다.
* components : 페이지 내부에서 사용하는 컴포넌트를 모아둔 폴더
* hooks : 직접 만든 훅을 모아둔 폴더
* types : 서버 응답 타입 등 공통으로 사용하는 타입을 모아둔 폴더
* utils : 애플리케이션 전역에서 공용으로 사용하는 유틸성 파일을 모아둔 폴더

❗ 폴더 구조에는 정답이 없다.

마지막으로 Next.js 프로젝트 실행, 빌드, 린트와 관련된 명령어를 package.json에 작성

```json
{
  ...
  "scripts": {
    "dev": "next dev",
    "start": "next start",
    "build": "next build",
    "lint": "eslint . --fix",
    "prettier": "prettier . --write"
  },
  ...
}

```

<br/>

### 👉 09-01-07. 추가로

1. 보일러플레이트 프로젝트를 만든 다음, 깃 허브에서 `Template repository`라는 옵션을 체크해두면 다른 저장소를 생성할 때 이 내용을 모두 복사해서 생성할 수 있다.
2. create-next-app처럼 나만의 create-app CLI를 만드는 것.<br/>`create-next-app`도 일단 하나의 템플릿을 미리 만들어 둔 다음, CLI로 사용자 입력을 받아 커스터마이징 한 것이다.

<br/><br/>

## 🌏 09-02. 깃허브 100% 활용하기

깃허브에서 제공하는 서비스를 활용해 프런트엔드 갭라에 어떤 도움을 얻을 수 있는 지 알아보자.

### 👉 09-02-01. 깃허브 액션으로 CI환경 구축하기

먼저 `CI(Continuous Integration)`에 대해 알아보자.

> CI (Continuouse Integration)
>
> 코드의 변화를 모으고 관리하는 중앙 저장소에서 여러 기여자가 기여한 코드를 지속적으로 빌드하고 테스트해 코드의 정합성을 확인하는 과정을 `CI`라고 한다.
>
> CI의 핵심은 코드의 변화가 있을 때마다 전체 소프트웨어의 **정합성을 확인하기 위한 작업(테스트, 빌드, 정적 분석, 보안 취약점 분석 등)을 자동**으로 실행해야 한다는 것이다.

과거에는 `젠킨스(Jenkins)`를 많이 사용했는데, 사용하는데 번거로운 측면이 많았다.<br/>많은 플러그인을 통해 다양한 기능들을 제공하지만, 설치형 솔루션이기 때문에 별도 서버를 구축해야하고, 서버내에서 젠킨스를 설치해야 하고, 또 젠킨스를 사용 중인 저장소와 연결하는 작업을 해야만 했다.

이런 젠킨스의 대안이 바로 **깃허브 액션**이다.

> 깃허브 액션
>
> 깃허브에서 출시한 SaaS로, 깃허브 저장소와 함께 사용할 수 있는 강력한 도구다.
>
> CI솔루션을 대체하기 위한 것이 아니라 본래 목적은 깃허브 저장소를 기반으로 깃허브에서 발생하는 다양한 이벤트를 트리거 삼아 다양한 작업을 할수 있게 도와주는 것이다.
>
> 다양한 작업에는 아래와 같은 것이 포함되어 있다.
>
> * 깃허브의 어떤 브랜치에 푸시가 발생하면 빌드를 수행한다.
> * 깃허브의 특정 브랜치가 메인 브랜치를 대상으로 풀리퀘스트가 열리면 빌드, 테스트, 정적분석을 수행한다.

즉, 깃허브를 둘러싼 다양한 이벤트를 기반으로 깃허브에서 제공하는 가상 환경에서 사용자가 원하는 작업을 수행할 수 있도록 도와주는 서비스다.

<br/>

#### 🔸 깃허브 액션의 기본 개념

* **러너(runner)** : 파일로 작성된 **깃허브 액션이 실행되는 서버**를 의미한다. 특별히 지정하지 않으면, 공용 깃허브 액션 서버를 이용하며, 별도 러너를 구축해 자체적으로 운영할 수 있다.

* **액션(action)** : 러너에서 실행되는 **하나의 작업 단위**. yaml로 작성된 내용을 하나의 액션으로 볼 수 있다.

* **이벤트(event)** : 깃허브 액션의 **실행을 일으키는 이벤트**를 의미한다. 필요에 따라 1개 이상의 이벤트를 지정할 수 있고, 특정 브랜치를 지정하는 이벤트도 가능하다.

  * `pull_request` : PR(pull request)과 관련된 이벤트로서 PR이 열리거나 닫히거나 수정되거나 할당되거나 리뷰요청 되는 등의 **PR관련된 이벤트**를 의미.
  * `issues` : 이슈와 관련된 이벤트로서 이슈가 열리거나 닫히거나 삭제되거나 할당되는 등 **이슈와 관련된 이벤트**를 의미
  * `push` : **커밋이나 태그가 푸시될 때 발생하는 이벤트**를 의미
  * `schedule` : 저장소에서 발생하는 이벤트와 별개로 특정 시간에 실행되는 이벤트를 의미한다. 시간은 cron(유닉스 계열 운영체제)에서 사용되는 시간을 의미한다.
  * `잡(jobs)` : **하나의 러너에서 실행되는 여러 스텝의 모음**을 의미한다. 하나의 액션에서 여러 잡을 생성할 수 있고, 특별히 선언한게 없다면 내부 가상머신에서 각 잡은 병렬로 실행된다.
  * `스텝(steps)` : **잡 내부에서 일어나는 하나하나의 작업**을 의미한다. 셀 명령어나 다른 액션을 실행할 수도 있다. 이 작업은 병렬로 일어나지 않는다.

  ❗ 스텝들을 엮어서 잡을 만들고, 여러 잡은 병렬로 실행되며, 잡을 하나 잇아 모아둔 것을 액션이라 한다.액션을 실행하는 것이 러너다.

  <br/>

  #### 🔸 깃허브 액션 작성하기

  액션을 작성하려면, 저장소의 루트에 `.github/workflows`폴더를 생성하고 내부에 파일을 작성하면된다. (.yml or .yaml)

  ```yml
  name: chapter7 build
  run-name: ${{ github. actor }} has been added new commit.
  
  on:
    push:
    	branches-ignore:
    		- 'main'
  
  jobs:
  	build:
  		runs-on: ubuntu-latest
  		steps:
  			- uses: actions/checkout@v3
  			- uses: actions/setup-node@v3
  				with:
  					node-version: 16
        - name: 'install dependencies'
        	working-directory: ./chapter7/my-app
        	run: npm ci
        - name: 'build'
        	working-directory: ./chapter7/my-app
        	run: npm run build
  ```

  저장소에 Prettier가 설치돼 있다면 yaml 파일도 함께 포함시켜 코드 스타일을 유지하는 것이 좋다.

  위의 파일은 Next.js애플리케이션의 빌드를 확인하는 CI액션이다. `./github/workflows/build.yaml`이란 이름으로 저장한 다음, 별도 브랜치에서 푸시하고 풀 리퀘스트를 만들어 확인하자.

  그리고 `Details`를 눌러 CI가 어떤 절차를 거쳐 완료 됐는지 확인할 수 있다. 별도 설정이 없으면 공개 저장소는 90일, 비공개 저장소는 400일이 지나면 로그가 삭제된다.

  

  